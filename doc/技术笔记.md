[TOC]

## 技术笔记

### A. pyqt学习记录

#### Widget dialog layout

widget意为小组件，QWidget是一块空白块，一般qtdesignor里使用的都是xxxwidget，有特定功能，比较方便，比如Qmainwindow有菜单栏和状态栏。

dialog是特化的用户交互窗口，一般有yes、no选项，以及一些用户需要填写的信息，调用该窗口一般希望阻塞其他用户操作，逼迫其填写完毕后执行后续操作。

layout是小组件里嵌套组件的基本布局。萌新时期不懂这个作用，直接拖widget写了个窗口发现窗口禁不起拖动，因为组件坐标是绝对值，拉长之后不会重新布局。使用了layout就可以在窗口拖动后实现自动的重新布局，虽然可能效果不理想，需要进一步微调，但起码不至于离谱到找不到了。

#### 坐标系

在实现graphics一系列操作时不可避免地涉及到坐标系，pyqt总共有三个坐标系。

- 视图坐标（view coordinates），显示器物理坐标。所有小组件（widget）都使用这个坐标，即坐标原点在窗口左上角，y轴正方向向下。这是一个比较符合计算机书写逻辑的坐标系（参照excel表格），这个时候窗口大小也比较好表示，就是右下角坐标值。
- 场景坐标（scene coordinates），场景逻辑坐标。这是为了方便场景表示而采用的坐标系，即在qgraphicsscene中，坐标原点可以不是左上角（但是y轴还是朝下），程序员可以自定义取景框，取景框大小也不一定需要与视图大小一致，即支持放缩。场景中的顶层物体基于这个坐标系存储位置，与视图坐标之间存在转换矩阵。
- 图元坐标（item coordinates），图元逻辑坐标。为了方便图元之间实现嵌套表示而采用的坐标系，与场景坐标之间存在一个变换。嵌套的图元采用这个坐标系存储位置。

#### Model/view模型

[model / view programming](https://doc.qt.io/qt-5/model-view-programming.html)

##### 简介

MVC模型分离了数据、视图和操作，在Qt里简化成了M/V模型。具体到项目中遇到了一份数据两种形式显示的问题，虽然使用成熟的widget组件也可以轻松完成，但是数据需要存两份，同步起来不方便，也不利于后续数据库扩展（maybe），另外也是为了练手，采用model/view模型。

这里model/view虽然本意是一个model对应多个view，但是项目中两个view差异过大，不太容易用一个model表示，故写了两个model（数据还是只有一份，model可以看做基本数据操作模型）

![modelview-overview](https://raw.githubusercontent.com/lxambulance/cloudimg/master/img/modelview-overview.png?token=AGF5OL5FNAG3UCNCZGLSOSLAUINEK)

Qt中model都是根据QAbstractItemModel这个抽象类继承而来，该类定义了基本的视图或代理访问数据的接口，数据没有必要直接存在model里（就可以很方便的改写接数据库），而是由数据结构、分离的类、文件、数据库或其他应用组件完成。

Qt提供三种基本的视图，QListView、QTreeView和QTableView，使得用户可以定义少量的函数就直接使用。

##### 代理模型

简单来说就是遇到类似选择、排序和过滤等操作时，通过一层叠加的模型可以比较方便实现。（没有具体了解，或许项目中两个视图显示一份数据可以通过代理模型过滤）

##### 代表

代表delegate用于处理一些实时的渲染逻辑，比如重写paint()函数实现进度条加载。目前项目中只在进度条这用到了。简单阅读了文档，还可以做一些简单的功能例如编辑等操作。

##### 图形视图结构

类似于模型视图结构，不过这次的模型是图元，相对来说比model复杂一点，因为要考虑显示。使用图形视图结构的好处在于

- 提供了快速的接口管理大量的图元
- 可以传递事件到每个具体选择的图元
- 统一管理图元的状态信息，比如选择和关注（focus不知道怎么翻译，具体意思就是获取键盘控制权）
- 提供渲染转换函数，方便输出

题外话：Qt提供了四种类用于处理图像信息：QImage、QPixmap、QBitmap和QPicture。QImage是设计用于优化读写以及直接的像素级访问和操作，QPixmap是设计用于优化屏幕显示，QBitmap是一个继承于QPixmap且每个像素只有0/1的简单图像，QPixture是跟随画图类定义的一个用于执行画图操作的类。

#### 扩展数据信号

基本的Qt信号使用如下，就这么玩。

```python
from PyQt5.QtCore import QObject , pyqtSignal

class CustSignal(QObject):
    #声明无参数的信号
    signal1 = pyqtSignal()
    #声明带一个int类型参数的信号
    signal2 = pyqtSignal(int)
    #声明带int和str类型参数的信号
    signal3 = pyqtSignal(int,str)
    #声明带一个列表类型参数的信号
    signal4 = pyqtSignal(list)
    #声明带一个字典类型参数的信号
    signal5 = pyqtSignal(dict)
    #声明一个多重载版本的信号，包括带int和str类型参数的信号和带str类型参数的信号
    signal6 = pyqtSignal([int,str], [str])
    
    #将信号连接到指定槽函数
    self.signal1.connect(self.signalCall1)
    self.signal2.connect(self.signalCall2)
    self.signal3.connect(self.signalCall3)
    self.signal4.connect(self.signalCall4)
    self.signal5.connect(self.signalCall5)
    #重载版本的使用需要指明类型
    self.signal6[int,str].connect(self.signalCall6)
    self.signal6[str].connect(self.signalCall6OverLoad)
```

通过lambda函数可以做一些简单的扩展，更复杂的操作建议写闭包，lambda功能有限。

```python
    #将接受一个变量的槽改成了不接受变量的槽，通常这些操作用在循环里，i是循环变量
    self.signal2.connect(lambda:self.signalCall2(i))
```

#### 多线程与进程

具体参考[PyQt5 tutorial](https://www.mfitzp.com/courses/pyqt/)

本项目参考上述教程，直接将新建线程的操作抽象为新建一个worker类，然后通过信号绑定的操作实现线程之间的内容交互。

#### qt中exec_和show的区别

遇到窗口调用的时候老是遇到，总是存在疑问，暂时混用也没遇到什么大问题。

> QDialog的显示有两个函数show()和exec()。
>
> **show():**
> 显示一个非模态对话框。控制权即刻返回给调用函数。弹出窗口是否为模态对话框，取决于modal属性的值。
> （原文：Shows the dialog as a modeless dialog. Control returns immediately to the calling code. The dialog will be modal or modeless according to the value of the modal property. ）
>
> **exec():**
> 显示一个模态对话框，并且锁住程序直到用户关闭该对话框为止。函数返回一个DialogCode结果。在对话框弹出期间，用户不可以切换同程序下的其它窗口，直到该对话框被关闭。
> （原文：Shows the dialog as a modal dialog, blocking until the user closes it. The function returns a DialogCode result. Users cannot interact with any other window in the same application until they close the dialog. ）

在实现上，exec仅仅是在show的基础上加了一个事件循环来阻塞当前事件。所以使用show()加modal=True的方式仅仅是半模态，当前事件不会停止，立刻进行后续动作，与exec还是存在区别。

#### sizePolicy

以下为qt widget基本的大小扩展策略，其余一些为以下的组合，多数时候不需要关心这个，只要正确使用了layout和widget的嵌套，qt会自动排布。只有当自动排布不太合适的时候才应该考虑这个。项目中在qdockwidget中用到了，因为位置太窄了，插入listwidget只能选水平空间ignore，有多少占用多少。

| `QSizePolicy::GrowFlag`   | `1`  | The widget can grow beyond its size hint if necessary.       |
| ------------------------- | ---- | ------------------------------------------------------------ |
| `QSizePolicy::ExpandFlag` | `2`  | The widget should get as much space as possible.             |
| `QSizePolicy::ShrinkFlag` | `4`  | The widget can shrink below its size hint if necessary.      |
| `QSizePolicy::IgnoreFlag` | `8`  | The widget's size hint is ignored. The widget will get as much space as possible. |

### B. Packaging文件打包

##### pyinstaller

使用pyinstaller打包文件。

```bash
python -m venv packenv
call packenv\scripts\activate.bat
pip install pyqt5 pyinstaller
```

第一次打包直接运行pyinstaller app.py将生成build与dist两个文件夹，build包含调试用信息，dist(distribute)包含需要分发的所有文件（比如windows环境中包含exe）；另外生成了**.spec**文件，该文件是python语言的编译选项，可以做python运算。

之后修改后打包可以通过运行pyinstaller app.spec来完成。

运行pyinstaller时添加-n "app name"可以为生成的应用添加文件名，-w可以去除运行时的后端控制台，--onefile可以生成一个EXE文件（虽然便于分发，但是运行时启动比较慢），--icon可以指定生成的EXE文件的.ico图标，主窗口图标由主程序窗体类自行设置，windows菜单栏图标可以按照下方代码设置。

```python
try:
    # Include in try/except block if you're also targeting Mac/Linux
    from PyQt5.QtWinExtras import QtWin
    myappid = 'mycompany.myproduct.subproduct.version'
    QtWin.setCurrentProcessExplicitAppUserModelID(myappid)
    # or use ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID
except ImportError:
    pass
```

使用pyinstaller打包时，源文件中的文件路径指定的文件不会添加到打包文件夹中（当然，那就是个字符串路径，会硬编译到程序中），所以分发时需要带着资源文件一起分发，比较麻烦。

通过--add-data="your_icon.ico;."或者在.spec中analysis部分添加datas=[('your_icon.ico','.')]可以将资源文件导入dist文件夹。

除此之外，通过qt resources system可以直接将资源文件转化为python文件，就不需要考虑添加文件。

最后整个dist文件夹可以通过installForge软件打包成安装包，分发给用户安装。

##### fbs

fbs是跨平台pyqt5打包工具，它是基于pyinstaller的扩展版本，实现了更为简单的自动化打包。

### C. Json

**J**ava**S**cript **O**bject **N**otation（javascript对象表示法），存储和交换文本信息的语法，类似XML。由于其字符串的存储形式，便于进程交互，另外python自带的库文件可以直接解析相应结构。

#### 简单操作

```python
import json # python3.9自带
a = json.dumps(['foo',{'bar':('baz',None,1.0,2)}]) # 将json格式转化为python str
b = json.loads(a) # 将python str转化为json格式（python list）
# 下面两个函数用于文件操作
json.dump(obj, fp)
obj = json.load(fp)
```

#### Json Python类型转换表

|     JSON     | Python |
| :----------: | :----: |
|    object    |  dict  |
|    array     |  list  |
|    string    |  str   |
| number(int)  |  int   |
| number(real) | float  |
|     true     |  True  |
|    false     | False  |
|     null     |  None  |

### D. pylint代码书写规则

1. 模块，类，函数都要用格式'''docstring:...'''写docstring且不能为空，描述相应对象用来做什么即可
2. 模块命名采用snake_case naming style，即单词用小写，连接单词用下划线
3. 类命名采用PascalCase naming style，即类名第一个字母大写，其他小写
4. 代码块最后多且仅多一行
5. 等号左右都有空格
6. 用逗号分隔参数时，逗号后要有一个空格
7. 一个类最好至少两个public函数
8. constant常量用全大写来命名

虽然我也经常不遵守规则，但最好写代码清醒的时候起名注意点。

### E. git使用

#### 基本操作

```shell
# 文件操作
git add/rm file/folder # 文件（文件夹）在暂存区添加/删除
git commit -m "message" # 提交到本地版本库
git checkout --filename # 撤销工作区文件修改
git reset HEAD filename # 撤销暂存区文件修改
git diff filename # 比较文件修改，先比较暂存区，没有时比较工作区

# 查看操作
git status # 查看工作区修改情况
git log # 查看git历史信息
git log --oneline # 一行简洁显示历史信息
git log --graph # 显示对应合并分支图

# 分支管理
git branch name # 创建分支，-d删除
git checkout name # 切换分支，-b创建且切换
git merge name # 将name分支与当前所在分支合并，此时默认会触发快速合并，加--no-ff可以关闭

# 连接github
git config --global user.email "email" # 设置本地全局用户邮箱
git config --global user.name "name" # 设置本地全局用户名
ssh-keygen -t rsa -C "email" # 生成ssh密钥，加密算法可换，生成的公钥文件内容需要添加到github网站方可正常访问。
ssh -v git@github.com # ssh连接测试

# 远程库管理
git remote -v # 显示远程库绑定情况
git remote rename a b # 将远程库a改名为b
git remote add git_address # 增加远程库关联
git clone git_address # 克隆远程库，默认下载master分支
git checkout -b dev origin/dev # 新建并连接本地库dev与远程库dev
git branch --set-upstream-to dev origin/dev # 连接远端库与本地库，远程库默认名origin，可以git remote rename改名
git branch -vv # 查看远程库与本地库连接情况
git branch -a #查看所有分支，包括远程库
git push --set-upstream origin test # 将当前分支推送到远程test分支
git push origin --delete test # 将远程test分支删除

# 其他
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit" # 设置命令别名

# git标签
git tag # 列出已有的标签信息
# git中有两种标签，附注标签是一条完整的记录，轻量标签用于临时打标记
git tag -a version -m "这是一条附注标签" # 完整的附注标签
git tag version # 轻量标签
git tag -a version 9fceb02 # 可以给以前的某次提交打上标签，方便后续查找
# 标签可以像分支操作一样引出其他分支
git checkout -b test v1.0 # 从tag v1.0引出分支test，这是一种比较常用的测试法
git push origin version # 推送tag到远程库
git push origin --tags # 推送本地所有tag到远程库
```

本地库目录下创建.gitignore 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。

#### 多人协作

主分支master，开发分支dev只有一个。只上传dev分支，master分支视dev分支完成情况合并。

dev分支clone到本地后新建自己的分支，代码完事后合并到dev分支然后提交。一下代码主要描述由于多人协作发生的git push失败后的处理。

```shell
# 首先配置github的ssh，拥有访问权限

# 第一次获取代码
git clone git_address # 默认下载默认库
git checkout -b dev origin/dev

# 修改后提交
git push origin dev # dev是远程库对应分支名

# 出现冲突
git pull --rebase # 建议加rebase，这样简单的修改（不涉及到他人代码部分）直接变成一条分支，显示效果比较好

# 修改完冲突后再次正常提交即可
# 奇怪的分支操作具体参见上一小节中的远程库操作
```

#### commit提交要求

```text
<type>(<scope>):<subject>

type(必须)
feat：新功能（feature）。
fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。
	fix：产生diff并自动修复此问题。适合于一次提交直接修复问题
	to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix
docs：文档（documentation）。
style：格式（不影响代码运行的变动）。
refactor：重构（即不是新增功能，也不是修改bug的代码变动）。
perf：优化相关，比如提升性能、体验。
test：增加测试。
chore：构建过程或辅助工具的变动。
revert：回滚到上一个版本。
merge：代码合并。
sync：同步主线或分支的Bug。

scope(可选)
scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。
例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。
本项目中没有太大的架构，可以指明文件替代。

subject(必须)
subject是commit目的的简短描述，不超过50个字符。
建议使用中文（感觉中国人用中文描述问题能更清楚一些）。
结尾不加句号或其他标点符号。

范例
fix(DAO):用户查询缺少username属性
feat(Controller):用户查询接口开发
```

### F. Scapy定义新协议

scapy是一个有趣的可以交互的网络工具库，当前为了方便发包，详细阅读了相关教程文档[Adding a new protocols](https://scapy.readthedocs.io/en/latest/build_dissect.html)，完成了几个小工具，文件均存放在test/下，后续可能用来做交互界面。

scapy的强大在于写完包格式框架后，对于一段网络报文，它可以自己推导构建，省去了诸多不方便的地方，另外还可以诸如自动计算checksum，pkg_length等报文字段，用 **/** 符号可以连接上下层协议。以下记录了一些使用心得。

scapy报文存在三种格式，**i**(nternal)是scapy内部存储的格式，与python对象基本没有区别，各种字段的值就是int或str或list；**m**(achine)是网络报文格式，是实际发包的内容，一般在发包前做最后的转化；**h**(uman)是便于人类读取的格式，将python对象有层次的展示出来，便于命令行交互。

定义报文只需要编写fields_desc列表各字段格式，[教程文档](https://scapy.readthedocs.io/en/latest/build_dissect.html)里详细介绍了报文定义之后后续代码如何转换，简单来说Packet使用Field类定义各字段，Field类不是一个个实体，反而有点像一个专用处理组件，负责处理自己这个字段的格式转换，然后Packet工厂按字段顺序交给组件处理，最后拼接形成网络报文，还比较有趣。

遇到的第一个比较头疼的问题是Field字段大小，一下给了一些常用字段大小，看名字基本可以猜出字段大小，然后前面加**X**表示16进制，加**Signed**表示有符号数，加**LE**表示字段为小端表示。其他有些可以自定义大小，非常方便，具体如何可以使用参考源码。

```python
ByteField
XByteField

ShortField
SignedShortField
LEShortField
XShortField

X3BytesField        # three bytes as hex
LEX3BytesField      # little endian three bytes as hex
ThreeBytesField     # three bytes as decimal
LEThreeBytesField   # little endian three bytes as decimal

IntField
SignedIntField
LEIntField
LESignedIntField
XIntField

LongField
SignedLongField
LELongField
LESignedLongField
XLongField
LELongField

IEEEFloatField
IEEEDoubleField
BCDFloatField       # binary coded decimal

BitField
XBitField

BitFieldLenField    # BitField specifying a length (used in RTP)
FlagsField
FloatField
```

第二个主要使用的功能是变长类型字段，有一个字段描述列表字段个数或长度，然后列表字段存储相应个数或长度的内容，这个只需要使用在字段后加count_of和count_from即可（长度对应length_of和length_from），如下代码所示，值得注意的是adjust可以调整count出的结果，对于一些数量不实际对应列表数量的字段非常方便。这里有一点疑惑的是为什么需要两个函数，一个count_of，一个count_from而且二者看起来是反函数。原因是两者用于不同的流程，一是构造，一是解包，前者需要在生成时自动统计个数，后者需要在解析时确定列表大小。

```python
class TestPLF(Packet):
    fields_desc=[ 
        FieldLenField("len", None, count_of="plist", 
        	adjust=lambda pkt,x:x),
        PacketListField("plist", None, IP,
        	count_from=lambda pkt:pkt.len)
    ]
```

第三个主要使用的功能是后处理自动计算checksum字段。使用post_build函数可以在基本字段构造完后，再处理一些需要最后处理的字段，比如报文总长度和checksum，具体代码如下。这个时候需要直接操作最后的网络报文，需要知道对应字段所在字节位置，另外这个结果是个python的bytes类型。

```python
def post_build(self, pkt, pay):
        if self.header_length is None:
            self.header_length = len(pkt)
            pkt = pkt[:6] + int2Bytes(self.header_length, 1) + pkt[7:]
        if self.pkg_length is None:
            self.pkg_length = len(pkt) + len(pay)
            pkt = pkt[:2] + int2BytesLE(self.pkg_length, 2) + pkt[4:]
        if self.checksum is None:
            self.checksum = CalcChecksum(pkt)
            pkt = pkt[:4] + int2Bytes(self.checksum, 2) + pkt[6:]
        # print(self.pkg_length, self.header_length, self.checksum)
        return pkt + pay
```

最后要说的是scapy一个比较灵活的胶水语言特性，bind_layers函数，用法如下，然后构造是可以直接在CoLoR_Control包后边接IP_nid包，解析时也会根据tag推敲后续包类型。比较坑爹的一点是无法处理冲突，即有多个条件满足的时候是会使用第一个定义类型，所以有时候不如不用。bind_layers更进一步的推导函数是guess_payload_class(self, payload)，它可以有更丰富的条件判断。

```python
# 用于解析时推导负载字段
bind_layers(CoLoR_Control, IP_nid, tag="PROXY_REGISTER")
# 用于构建时自动填写tag字段
bind_layers(CoLoR_Control, IP_nid, {'tag':5})
```

### G. 图标

项目图标部分来自[fugue-icons-3.5.6](https://p.yusukekamiyamane.com/)，由[pyqt教程网站](https://www.learnpyqt.com/)推荐。

另外部分来自[图标网站](https://www.flaticon.com/)

### H. python venv

python虚拟环境，为了安装第三方插件不污染python主环境，而另建一个虚拟环境，隔离管理。

```shell
# 新建虚拟环境文件夹
python3 -m venv tutorial-env
# ubuntu启动虚拟环境
source tutorial-env/bin/activate
# ubuntu退出虚拟环境
deactivate

# 之后就是正常的第三方库安装和运行
# 一键安装全部依赖库
python3 -m pip install -r requirments.txt
```



